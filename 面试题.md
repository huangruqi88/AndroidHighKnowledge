### 1、蓝牙的实现原理
[蓝牙的实现原理](https://www.jianshu.com/p/4ecc99679451)


### 2、EventBus的实现原理 
[Android EventBus 的源码解析](https://www.jianshu.com/p/83e44261e095)
### 3、Glide 加载同一路径的不同图片  答：关闭缓存
### 4、接口设计如何避免被抓包
 [https://blog.csdn.net/rooney8/article/details/108264244](https://blog.csdn.net/rooney8/article/details/108264244)
### 5、Glide源码分析 

[Glide源码分析 的源码解析](https://www.jianshu.com/p/f22021d00f3a)

### 6、Hashmap的原理是怎么实现键唯一的。
### 7、binder 的实现原理


[Binder机制的原理](https://www.jianshu.com/p/adaa1a39a274)

+ Binder的定向制导，如何找到目标Binder，唤起进程或者线程
+ Binder中的红黑树，为什么会有两棵binder_ref红黑树
+ Binder一次拷贝原理(直接拷贝到目标线程的内核空间，内核空间与用户空间对应)
+ Binder传输数据的大小限制（内核4M 上层限制1m-8k），传输Bitmap过大，就会崩溃的原因，Activity之间传输BitMap
+ 系统服务与bindService等启动的服务的区别
+ Binder线程、Binder主线程、Client请求线程的概念与区别
+ Client是同步而Server是异步到底说的什么
+ Android APP进程天生支持Binder通信的原理是什么
+ Android APP有多少Binder线程，是固定的么
+ Binder线程的睡眠与唤醒（请求线程睡在哪个等待队列上，唤醒目标端哪个队列上的线程）
+ Binder协议中BC与BR的区别
+ Binder在传输数据的时候是如何层层封装的--不同层次使用的数据结构（命令的封装）
+ Binder驱动传递数据的释放（释放时机）
+ 一个简单的Binder通信C/S模型
+ ServiceManager addService的限制（并非服务都能使用ServiceManager的addService）
+ bindService启动Service与Binder服务实体的流程
+ Java层Binder实体与与BinderProxy是如何实例化及使用的，与Native层的关系是怎样的
+ Parcel readStrongBinder与writeStrongBinder的原理
+ 同一个线程的请求必定是顺序执行，即使是异步请求(oneway)

[听说你Binder机制学的不错，来面试下这几个问题（一）](https://www.jianshu.com/p/adaa1a39a274)

### 8、Activity的启动原理
### 9、jvm、davike和ART的区别
![java内存模型.png](https://z3.ax1x.com/2021/07/26/WRWjM9.png)
##### 1.程序计数器（Program Counter Register）：是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置
	Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，需要记录代码
	已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。
###### 分支操作、循环操作、跳转、异常处理等也都需要依赖程序计数器来完成。
	注意：
		1、在 Java 虚拟机规范中，对程序计数器这一区域没有规定任何 OutOfMemoryError 情况。
		2、线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
		3、当一个线程正在执行一个 Java 方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。
##### 2.虚拟机栈是线程私有的，与线程的生命周期同步。
	1.StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出。
	2.OutOfMemoryError：当 Java 虚拟机动态扩展到无法申请足够内存时抛出。
### 10、mvvm和mvp的区别，jekpet 
	 答：https://blog.csdn.net/qq_36425800/article/details/110739691
### 11、java类的加载过程
 https://blog.csdn.net/xuemengrui12/article/details/82707473
### 12、组件化，模块化
### 13、Android的四大组件有哪些？各自有什么作用？
### 14、Activity的声明周期
### 15、Activity的启动模式，区别是什么？
### 16、Service有几种启动方式？区别是什么？
### 17、ANR产生的原因是什么？
### 18、强引用、软引用、弱引用和虚引用的区别
### 19、java中堆和栈的区别？
### 20、String、StringBuilder和StringBuffer有什么区别？
### 21、LRUCache算法原理 https://www.jianshu.com/p/8a5e1e66c10b
### 22、HashMap 使用可变对象作为key会发生什么？ 
### 23、HashMap 底层实现原理 

	HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。

https://blog.csdn.net/meng_xiaohua/article/details/80845149

### 24、HashMap之Hash碰撞 答：链表法和开放地址法。https://www.jianshu.com/p/379680144004
### 25、Bitmap优化  
	答：1、BitmapConfig的配置 
		2、使用decodeFile、decodeResource、decodeStream进行解析Bitmap时，配置inDensity和inTargetDensity，两者应该相等,值可以等于屏幕像素密度*0.75f 
		3、使用inJustDecodeBounds预判断Bitmap的大小及使用inSampleSize进行压缩 
		4、对Density>240的设备进行Bitmap的适配（缩放Density） 
		5、2.3版本inNativeAlloc的使用 
		6、4.4以下版本inPurgeable、inInputShareable的使用 
		7、Bitmap的回收
### 26、Glide是如何管理生命周期的？
### 27、OpenGL是如何实现美颜相机和3D模型的加载的？
### 28、Android进程间通讯？
	答：https://www.jianshu.com/p/392922c1b036
### 29、Binder 与aidl的区别？ 

	答：https://blog.csdn.net/Android_SE/article/details/104187030

### 30、线程池的数量大小？
	答：如果是CPU密集型应用，则线程池大小设置为N+1，如果是IO密集型应用，则线程池大小设置为2N+1。 Runtime.getRuntime().availableProcessors() https://blog.csdn.net/ldhj1993/article/details/72666867 
### 31、堆和栈有什么区别？ 
	答：https://blog.csdn.net/jianghao233/article/details/82777789  https://www.cnblogs.com/itsharehome/p/11290907.html
### 32、WebView的优化
### 33、LeakCanery 基本原理

		监听Activity生命周期->onDestroy以后延迟5秒判断Activity有没有被回收->如果没有回收,调用GC，再此判断是否回收，如果还没回收，则内存泄露了，反之，没有泄露。
	https://www.cnblogs.com/jymblog/p/11656221.html

### 34、Glide的优缺点？为什么不用其他的加载框架？
### 35、Glide的生命周期
### 36、ButtkerKnife是怎么实现的？
### 37、深入理解WebView在Application中提前初始化

		1.实现WebView复用
		2.另开WebView进程
		3.DNS解析优化（接口与网页主域名一致）
		4.线上资源压缩、CDN加速
		5.静态直出，直接下发首屏html
		6.离线预推，下发离线包，并增量更新
		7.WebView创建与网络请求并行
		8.网页按节点局部刷新
		9.自定义实现图片资源缓存
		10.重新定义图片加载格式，shareP
		11.本地资源拦截替换

### 38、RxJava是怎么做线程调度的？
### 39、Activity、Fragment的生命周期？
Activty: onCreat() --> onStart() --> onResume() --> onPause() --> onStop() --> onDestry()

Fragment: onAttch() --> onCreate() --> onCreateView() -->onActtivityCreate() --> onStart() --> onResume() --> onPause --> onStop() -- onDestrtyView() --> onDettch()

[![Activty.png](https://z3.ax1x.com/2021/09/05/hW31bj.png)](https://imgtu.com/i/hW31bj)
[![Fragment生命周期.png](https://z3.ax1x.com/2021/09/05/hW3NGV.png)](https://imgtu.com/i/hW3NGV)

### 40、Context有哪些实现类？

[![Context实现类.png](https://z3.ax1x.com/2021/09/05/hW3qRf.png)](https://imgtu.com/i/hW3qRf)

### 41、Android之SharedPreferences详解与原理

sp.edit()每次都会返回一个新的Editor对象，Editor的实现类EditorImpl里面会有一个缓存的Map，最后commit的时候先将缓存里面的Map写入内存中的Map，然后将内存中的Map写进XML文件中。使用上面的方式commit，由于sp.edit()又重新返回了一个新的Editor对象，缓存中的Map是空的，所以导致数据无法被存储。

[SharedPreferences原理](https://blog.csdn.net/user_app/article/details/80504394 )

### 43、数据库多表联查以及大数据量怎么做？
1. **多表联查**
+ 第一张表是动物的种类信息，有猫、狗、鸟三种，表名：animal
+ 第二张表是一种动物的具体种类，猫有波斯猫（persian）、 伯曼猫（birman）、布偶猫 （ragdoll）；狗有维兹拉犬（vizsla）、波利犬（puli）、蝴蝶犬（papillon）；鸟有杜鹃鸟（cuckoo）、布谷鸟（eagle ）、鹰（Egret），表名：classify。
+ 两张表的联系是有相同的anim_id ，请留意，”anim_id” 列把上面的两个表联系了起来

[Android Sqlite数据库多表联合查询](https://blog.csdn.net/liuwanyouyue/article/details/58588208)
2. **大数据量**

1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
3.应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。

4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。

[SQLite大量数据表的优化](https://www.jianshu.com/p/ce6e245783e8)

### 44、Apk的构建过程。

	   AndroidManifest.xml       程序全局配置文件
	   classes.dex                Dalvik字节码
	   resources.arsc             资源索引表, 解压缩resources.ap_就能看到
	   res\                      该目录存放资源文件(图片，文本，xml布局)
	   assets\                    该目录可以存放一些配置文件
	   src\                       java源码文件
	   libs\                     存放应用程序所依赖的库
	   gen\                     编译器根据资源文件生成的java文件
	   bin\                      由编译器生成的apk文件和各种依赖的资源
	   META-INF\                该目录下存放的是签名信息

		2.1）AAPT（Android Asset Packaging Tool）工具，Android资源打包工具。会打包资源文件（res文件夹下的文件），并生成R.java和resources.arsc文件。

		2.2）AIDL工具会将所有的.aidl文件编译成.java文件。
		2.3）JAVAC工具将R.java、AIDL接口生成的java文件、应用代码java文件编译成.class文件。
		2.4）dx脚本将很多.class文件转换打包成一个.dex文件。
		2.5）apkbuilder脚本将资源文件和.dex文件生成未签名的.apk文件。
		2.6）jarsigner对apk进行签名。

### 45、怎么理解高内聚低耦合？
### 46、Socket通信
### 47、Java类加载的过程
### 48、Java 内存比例 
[https://blog.csdn.net/weixin_33810114/article/details/115632067](https://blog.csdn.net/weixin_33810114/article/details/115632067)
### 49、LeakCanary原理
![LeakCanary原理.png](https://z3.ax1x.com/2021/07/29/WbY2tS.png)
LeakCanary对于内存泄漏的检测非常有效，但也并不是所有的内存泄漏都能检测出来。

+ 无法检测出Service中的内存泄漏问题
+ 如果最底层的MainActivity一直未走onDestroy生命周期(它在Activity栈的最底层)，无法检测出它的调用栈的内存泄漏。
[https://www.jianshu.com/p/261e70f3083f](https://www.jianshu.com/p/261e70f3083f "LeakCanary原理解析")

### 50、Android 多进程导致 Application 重复创建问题

[Android 多进程导致 Application 重复创建问题](https://conorlee.top/2017/02/21/Multi-Process-Dispatch/)

### 51、什么是插件化与组件化？

1. 插件化
优点：
1.宿主与插件分开编译，互不影响
2.插件可独立运行，充分解耦
3.按需加载插件模块，减少宿主体积
4.动态更新插件模块
5.发版灵活：不用上架，不需用户主动更新

常用的插件化框架：
1.RePlugin
360开源的RePlugin 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案
2.Shadow
腾讯出品的零反射全动态Android插件框架
3. Small
Small，做最轻巧的跨平台插件化框架。

2. 组件化：将一个app分成多个模块，每个模块都是一个组件（Module），开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件合并统一成一个apk，这就是组件化开发。

优点：
1.将APP业务模块分开开发和维护，有利于提高效率
2.一个业务分为一个组件，每个组件可以单独开发以实现并发开发，进一步提高效率
3.每个组件充分解耦
4.每个组件可以单独测试
5.架构灵活

### 52、热修复？

### 53、多线程断点下载？

[多线程断点下载](https://www.jianshu.com/p/2b82db0a5181 "多线程断点下载")

### 54、RxJava如何做线程调度的？

subscribeOn()

+ 订阅顺序当从下到上，上游的ObservableSource被订阅时，先切换线程，然后立即执行task;
+ 当存在多个subscribeOn()方法时，仅第一个subscribeOn()有效。

observerOn()

+ 订阅顺序当从下到上，上游的ObservableSource被订阅时，会将对应的worker创建并作为构造参数存储在Observer的装饰器中，并不会立即切换线程；
+ 当数据由上游发送过来时，先将数据存储到队列中，然后切换线程，然后在新的线程中将数据发送给下游的Observer；
+ 当存在多个observerOn()方法时，仅对距下游下一个observerOn()之前的observer有效

[线程调度](https://www.jianshu.com/p/9e3930fbcb26)

[扔无线RxJava](https://gank.io/post/560e15be2dca930e00da1083)

### 54、Retrofit实现原理？

Retrofit使用的，就是动态代理，方法注解、建造者和适配器等成熟的技术或模式，但是由于她的设计紧凑，而且动态代理屏蔽了很多过程上的细节。

Retrofit实现原理
1. Retrofit使用动态代理，其实是为了开发者在写代码时方便调用，而真正负责生产Call网络工作对象的，还是Retrofit.create函数中定义的这个InvocationHandler

2. Retrofit使用了建造者模式，建造者模式的特定就是实现了建造和使用的分离，所以建造者模式的建造函数里，一般会有很复杂的对象创建和初始化过程，所以我们要看一下Retrofit的build函数。
3. 我们可以理解Retrofit根据接口定义动态生产Call网络请求工作对象的原理了，其实就是通过适配器把retrofit2.Call对象转换为目标对象。
4. 至于适配器转换过程中，如何实现的对象转换，就可以根据需求来自由实现了，比如利用静态代理等，如有必要，我们可以自行开发扩展，Retrofit框架并不限制我们对于适配器的实现方式。 

https://www.jianshu.com/p/f57b7cdb1c99

https://www.cnblogs.com/laiqurufeng/p/4498646.html































































