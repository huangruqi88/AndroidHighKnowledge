![java内存模型.png](https://z3.ax1x.com/2021/07/26/WRWjM9.png)
####1.程序计数器（Program Counter Register）：是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置
	Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，
	需要记录代码
	已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。
![程序计数器.png](https://z3.ax1x.com/2021/07/26/WW94y9.png)
######分支操作、循环操作、跳转、异常处理等也都需要依赖程序计数器来完成。
	注意：
		1、在 Java 虚拟机规范中，对程序计数器这一区域没有规定任何 OutOfMemoryError 情况。
		2、线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，
	随着线程的结束而死亡。
		3、当一个线程正在执行一个 Java 方法的时候，这个计数器记录的是正在执行的虚拟机字节
	码指令的地址。如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。
####2.虚拟机栈是线程私有的，与线程的生命周期同步。
**JVM 是基于栈(就是虚拟机栈)的解释器执行的，DVM 是基于寄存器解释器执行的。**
	1.StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出。
	2.OutOfMemoryError：当 Java 虚拟机动态扩展到无法申请足够内存时抛出。
#####栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。
	理解：一个线程包含多个栈帧，而每个栈帧内部包含局部变量表、操作数栈、动态连接、返回地址等。
![栈帧.png](https://z3.ax1x.com/2021/07/26/WWCq7q.png)
#####局部变量表
######局部变量表是变量值的存储空间，我们调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中。

在 Java 编译成 class 文件的时候，就会在方法的 Code 属性表中的 max_locals 数据项中，确定该方法需要分配的最大局部变量表的容量。如下代码所示：

	public static int add(int k) {
		int i = 1;
		int j = 2;
		return i + j + k;
	}
使用 javap -v 反编译之后，得到如下字节码指令：
	public static int add(int);
	  descriptor: (I)I
	  flags: ACC_PUBLIC, ACC_STATIC
	  Code:
	    stack=2, locals=3, args_size=1
	      0: iconst_1
	      1: istore_1
	      2: iconst_2
	      3: istore_2
	      4: iload_1
	      5: iload_2
	      6: iadd
	      7: iload_0
	      8: iadd
	      9: ireturn
上面的 locals=3 就是代表局部变量表长度是 3，也就是说经过编译之后，局部变量表的长度已经确定为3，分别保存：参数 k 和局部变量 i、j。

**注意：系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值），也就是说不存在类变量那样的准备阶段。这一点会在后续的 Class 初始化课时详细介绍。**
#####操作数栈（Operand Stack）
**操作数栈**也常称为操作栈，它是一个后入先出栈（LIFO）。

	同局部变量表一样，操作数栈的最大深度也在编译的时候写入方法的Code属性表中的max_stacks
	数据项中。栈中的元素可以是任意Java数据类型，包括long和double。

	当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。在方法执行的过程中，会有各种字节
	码指令被压入和弹出操作数栈（比如：iadd指令就是将操作数栈中栈顶的两个元素弹出，执行加法
	运算，并将结果重新压回到操作数栈中）。

#####动态链接
	动态链接的主要目的是为了支持方法调用过程中的动态连接（Dynamic Linking）。

	Java 虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引
	用的目的就是为了支持方法调用过程中的动态连接（Dynamic Linking）。具体过程会在后续的字节
	码执行课时中介绍。

#####返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法：

+ **正常退出：**指方法中的代码正常完成，或者遇到任意一个方法返回的字节码指令（如return）并退出，没有抛出任何异常。<br/>

+ **异常退出：**指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。

	无论当前方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。
	而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复它的上层方法执行状态。

	一般来说，方法正常退出时，调用者的 PC 计数值可以作为返回地址，栈帧中可能保存此计数值。而方
	法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。

######实例讲解
我用一个简单的 add() 方法来演示, 代码如下：

	public int add() {
	  int i = 1;
	  int j = 2;
	  int result = i + j;
	  return result + 10;
	}

我们经常会使用 javap 命令来查看某个类的字节码指令，比如 add() 方法的代码，经过 javap 之后的字节码指令如下：

	0: iconst_1    （把常量 1 压入操作数栈栈顶）
	1: istore_1    （把操作数栈栈顶的出栈放入局部变量表索引为 1 的位置）
	2: iconst_2    （把常量 2 压入操作数栈栈顶）
	3: istore_2    （把操作数栈栈顶的出栈放入局部变量表索引为 2 的位置）
	4: iload_1     （把局部变量表索引为 1 的值放入操作数栈栈顶）
	5: iload_2     （把局部变量表索引为 2 的值放入操作数栈栈顶）
	6: iadd        （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）
	7: istore_3    （把操作数栈栈顶的出栈放入局部变量表索引为 3 的位置）
	8: iload_3     （把局部变量表索引为 3 的值放入操作数栈栈顶）
	9: bipush 10   （把常量 10 压入操作数栈栈顶）
	11: iadd       （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）
	12: ireturn    （结束）

从上面字节码指令也可以看到，其实局部变量表和操作数栈在代码执行期间是协同合作来达到某一运算效果的。接下来通过图示来看下这几行代码执行期间，虚拟机栈的实际情况。

首先说一下各个指令代表什么意思：

+ **iconst 和 bipush**，这两个指令都是将常量压入操作数栈顶，区别就是：当 int 取值 -1~5 采用 iconst 指令，取值 -128~127 采用 bipush 指令。
+ **istore** 将操作数栈顶的元素放入局部变量表的某索引位置，比如 istore_5 代表将操作数栈顶元素放入局部变量表下标为 5 的位置。
+ **iload** 将局部变量表中某下标上的值加载到操作数栈顶中，比如 iload_2 代表将局部变量表索引为 2 上的值压入操作数栈顶。
+ **iadd** 代表加法运算，具体是将操作数栈最上方的两个元素进行相加操作，然后将结果重新压入栈顶。

首先在 Add.java 被编译成 Add.class 的时候，**栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的 Code 属性中。**因此这会局部变量表的大小是确定的，add() 方法中有 3 个局部变量，因此局部变量表的大小为 3，但是操作数栈此时为空。

所以代码刚执行到 add 方法时，局部变量表和操作数栈的情况如下：

![操作数栈与局部变量.png](https://z3.ax1x.com/2021/07/26/WWxJzj.png)
icons_1  把常量 1 压入操作数栈顶，结果如下：
![操作数栈与局部变量.png](https://z3.ax1x.com/2021/07/26/WWzClj.png)
**可以看出此时操作数栈重新变为空，并将出栈的元素 1 保存在局部变量表中。**

iconst_2 把常量 2 压入操作数栈顶，结果如下：

![WfSJrn.png](https://z3.ax1x.com/2021/07/26/WfSJrn.png)
istore_2 把操作数栈顶的元素出栈并放入局部变量表下标为 2 的位置，结果如下：
![WfDlHU.png](https://z3.ax1x.com/2021/07/26/WfDlHU.png)
接下来是两步 iload 操作，分别是 iload_1 和 iload_2。分别代表的是将局部变量表中下标为 1 和下标为 2 的元素重新压入操作数栈中，结果如下：















