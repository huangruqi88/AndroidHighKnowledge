## 引言

synchronized 原理时，已经了解了 Java 中线程的创建以及上下文切换是比消耗性能的，因此引入了偏向锁、轻量级锁等优化技术，目的就是减少用户态和核心态之间的切换频率。但是在这些优化基础之上，还有另外一个角度值得思考：创建和销毁线程非常损耗性能，那有没有可能复用一些已经被创建好的线程呢？答案是肯定的，那就是线程池。

另外，**线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的内存空间，在线程销毁时需要回收这些系统资源，频繁地创建销毁线程会浪费大量资源，而通过复用已有线程可以更好地管理和协调线程的工作。**

线程池主要解决两个问题：

一、 当执行大量异步任务时线程池能够提供很好的性能。<br/>
二、 线程池提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。
——《Java并发编程之美》

## 线程池体系

用一张图来表示线程池体系如下：

[![线程池体系01.png](https://z3.ax1x.com/2021/08/06/fncBSf.png)](https://imgtu.com/i/fncBSf)

解释说明：

+ **Executor 是线程池最顶层的接口，在 Executor 中只有一个 execute 方法，用于执行任务。至于线程的创建、调度等细节由子类实现。**

+ **ExecutorService 继承并拓展了 Executor，在 ExecutorService 内部提供了更全面的任务提交机制以及线程池关闭方法。**

+ **ThreadPoolExecutor 是 ExecutorService 的默认实现，所谓的线程池机制也大多封装在此类当中，因此它是本课时分析的重点。**

+ **ScheduledExecutorService 继承自 ExecutorService，增加了定时任务相关方法。**

+ **ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor，并实现了 ScheduledExecutorService 接口。**

+ **ForkJoinPool 是一种支持任务分解的线程池，一般要配合可分解任务接口 ForkJoinTask 来使用。**

## 创建线程池




































































































